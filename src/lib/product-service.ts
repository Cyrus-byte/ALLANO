
import { db } from '@/lib/firebase';
import { collection, addDoc, getDocs, getDoc, doc, deleteDoc, serverTimestamp, query, where, limit, updateDoc } from 'firebase/firestore';
import type { Product } from './types';

// Type for creating a new product (omitting fields generated by server)
type ProductInput = Omit<Product, 'id' | 'rating' | 'reviews' | 'isNew'>;

/**
 * Creates a new product in the Firestore database.
 * @param productData The data for the new product.
 * @returns The ID of the newly created product.
 */
export const createProduct = async (productData: Partial<ProductInput>) => {
  const productWithDefaults = {
    ...productData,
    price: productData.price || 0,
    images: productData.images || [],
    category: productData.category || 'Non class√©',
    brand: productData.brand || '',
    sizes: productData.sizes || [],
    colors: productData.colors || [],
    rating: 0,
    reviews: 0,
    isNew: true,
    onSale: productData.onSale || false,
    salePrice: productData.salePrice || null,
    createdAt: serverTimestamp(),
  };

  const docRef = await addDoc(collection(db, 'products'), productWithDefaults);
  return docRef.id;
};


interface GetProductsOptions {
    limit?: number;
    onSale?: boolean;
    isNew?: boolean;
    category?: string;
}

/**
 * Fetches products from Firestore with optional filters.
 * @param options Filter options for fetching products.
 * @returns A promise that resolves to an array of products.
 */
export const getProducts = async (options: GetProductsOptions = {}): Promise<Product[]> => {
    const productsCol = collection(db, 'products');
    
    let q = query(productsCol);

    if(options.onSale) {
        q = query(q, where("onSale", "==", true));
    }
    if(options.isNew) {
        q = query(q, where("isNew", "==", true));
    }
    if(options.category) {
        q = query(q, where("category", "==", options.category));
    }
    if(options.limit) {
        q = query(q, limit(options.limit));
    }
    
    const querySnapshot = await getDocs(q);
    const products: Product[] = [];
    querySnapshot.forEach((doc) => {
        const data = doc.data();
        products.push({
            id: doc.id,
            ...data
        } as Product);
    });

    return products;
}

/**
 * Fetches a single product by its ID from Firestore.
 * @param productId The ID of the product to fetch.
 * @returns A promise that resolves to the product, or null if not found.
 */
export const getProductById = async (productId: string): Promise<Product | null> => {
    if (!productId) {
        console.error("getProductById: productId is required.");
        return null;
    }
    try {
        const productRef = doc(db, 'products', productId);
        const productSnap = await getDoc(productRef);

        if (productSnap.exists()) {
            return { id: productSnap.id, ...productSnap.data() } as Product;
        } else {
            console.warn(`Product with ID ${productId} not found.`);
            return null;
        }
    } catch (error) {
        console.error(`Error fetching product with ID ${productId}:`, error);
        return null;
    }
}

/**
 * Updates an existing product in Firestore.
 * @param productId The ID of the product to update.
 * @param productData The data to update.
 */
export const updateProduct = async (productId: string, productData: Partial<Product>) => {
  if (!productId) {
    throw new Error("Product ID is required to update a product.");
  }
  try {
    const productRef = doc(db, 'products', productId);
    const dataToUpdate = { ...productData };
    if (!dataToUpdate.onSale) {
        dataToUpdate.salePrice = null; 
    }
    await updateDoc(productRef, dataToUpdate);
  } catch (error) {
    console.error(`Error updating product with ID ${productId}:`, error);
    throw new Error("Failed to update product.");
  }
};


/**
 * Deletes a product from Firestore.
 * @param productId The ID of the product to delete.
 */
export const deleteProduct = async (productId: string): Promise<void> => {
    if (!productId) {
        throw new Error("Product ID is required to delete a product.");
    }
    try {
        const productRef = doc(db, 'products', productId);
        await deleteDoc(productRef);
    } catch (error) {
        console.error(`Error deleting product with ID ${productId}:`, error);
        throw new Error("Failed to delete product.");
    }
};
