
import { db } from '@/lib/firebase';
import { collection, addDoc, getDocs, getDoc, doc, serverTimestamp, query, where, limit } from 'firebase/firestore';
import type { Product } from './types';

// Type for creating a new product (omitting fields generated by server)
type ProductInput = Omit<Product, 'id' | 'rating' | 'reviews' | 'isNew' | 'onSale' | 'salePrice'>;

/**
 * Creates a new product in the Firestore database.
 * @param productData The data for the new product.
 * @returns The ID of the newly created product.
 */
export const createProduct = async (productData: Partial<ProductInput>) => {
  const productWithDefaults = {
    ...productData,
    price: productData.price || 0,
    images: productData.images || [],
    category: productData.category || 'Non class√©',
    sizes: productData.sizes || [],
    colors: productData.colors || [],
    rating: 0,
    reviews: 0,
    isNew: true,
    onSale: false,
    createdAt: serverTimestamp(),
  };

  const docRef = await addDoc(collection(db, 'products'), productWithDefaults);
  return docRef.id;
};


interface GetProductsOptions {
    limit?: number;
    onSale?: boolean;
    isNew?: boolean;
    category?: string;
}

/**
 * Fetches products from Firestore with optional filters.
 * @param options Filter options for fetching products.
 * @returns A promise that resolves to an array of products.
 */
export const getProducts = async (options: GetProductsOptions = {}): Promise<Product[]> => {
    const productsCol = collection(db, 'products');
    
    let q = query(productsCol);

    if(options.onSale) {
        q = query(q, where("onSale", "==", true));
    }
    if(options.isNew) {
        q = query(q, where("isNew", "==", true));
    }
    if(options.category) {
        q = query(q, where("category", "==", options.category));
    }
    if(options.limit) {
        q = query(q, limit(options.limit));
    }
    
    const querySnapshot = await getDocs(q);
    const products: Product[] = [];
    querySnapshot.forEach((doc) => {
        const data = doc.data();
        products.push({
            id: doc.id,
            ...data
        } as Product);
    });

    return products;
}

/**
 * Fetches a single product by its ID from Firestore.
 * @param productId The ID of the product to fetch.
 * @returns A promise that resolves to the product, or null if not found.
 */
export const getProductById = async (productId: string): Promise<Product | null> => {
    if (!productId) {
        console.error("getProductById: productId is required.");
        return null;
    }
    try {
        const productRef = doc(db, 'products', productId);
        const productSnap = await getDoc(productRef);

        if (productSnap.exists()) {
            return { id: productSnap.id, ...productSnap.data() } as Product;
        } else {
            console.warn(`Product with ID ${productId} not found.`);
            return null;
        }
    } catch (error) {
        console.error(`Error fetching product with ID ${productId}:`, error);
        return null;
    }
}
